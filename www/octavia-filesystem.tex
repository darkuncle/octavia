\documentclass[letterpaper,9pt,twocolumn]{article}
%\documentclass[letterpaper]{article}
\usepackage{pslatex}

\begin{document}

\author{Chris Palmer}
\title{Octavia: A Secure Decentralized Filesystem}
\maketitle

\begin{abstract}

Octavia is a secure, fault-tolerant, decentralized network filesystem. It
provides data confidentiality, data integrity, client and server
authentication, simple access control, and redundancy. There is also the
potential for high performance (relative to other networked filesystems, in
certain deployment scenarios). Servers can set policy independently of
clients; clients may transparently make use of servers with widely varying
policies. 

%Slide 1: pic of Golden Gate Bridge. Software must be beautiful, must connect
%people, and must be safe.
%
%Slide 2: Civ, Mech, Chem, Aero Eng: Higher stakes, greater safety
%precautions. Software Eng: higher stakes, lesser safety precautions.

\end{abstract}


\section{Introduction}


\subsection{Prior Work}

Venti, the Plan 9 distributed filesystem (block IDs as hashes). Tahoe, other
other other thingies. TODO cites. MogileFS, MooseFS, Grolimund's thing,
Wuala, GlusterFS, Lustre.


\section{Core Protocol}

\subsection{Primitive Data Types}

In the following equations, $+$ indicates string concatenation.

Data stored in Octavia is stored as discrete units called blocks, simple
segments of a stream of bytes. The data in a block is a $blockData$. The
blocks are of a fixed size except for the final block, which can be between
1 and $BLOCK_{SIZE}$ bytes. $BLOCK_{SIZE}$ is a constant shared by all
protocol participants in a deployment. For low-latency deployments, it will
be wise to set $BLOCK_{SIZE}$ to fit an entire block within an Ethernet
frame (normal or jumbo).

The $blockID$ (equation~\ref{eqn:block-id}) is a globally unique
identifier for a $blockData$, generated using a cryptographic hash
(equation~\ref{eqn:hash}). We re-hash the output of the hash function in
order to work around a problem of iterative block hashes: $hash(M)$ is
a precursor to $hash(M + N)$.

% TODO cite Ferguson, others. Mention the other solution and talk about why
% we use this one. Or should we change?

\begin{equation}
blockID = hash(blockSize + blockData))
\label{eqn:block-id}
\end{equation}

\begin{equation}
hash(data) = SHA256(SHA256(data))
\label{eqn:hash}
\end{equation}

The protocol makes use of nonces (\ref{fig:Nonce}), which are generated in a
cryptographically random manner.

\begin{figure}[t]
{\small \begin{verbatim}
typedef char [16] Nonce;
\end{verbatim} }
\caption{Nonces are 128-bit cryptographically random objects.}
\label{fig:Nonce}
\end{figure}

The protocol uses cryptographic hashes for various purposes.

\begin{figure}[t]
{\small \begin{verbatim}
typedef char [32] Hash;
\end{verbatim} }
\caption{Block signatures are 256-bit cryptographic hash values.}
\label{fig:Signature}
\end{figure}

\subsection{Message Types}

Storage Requests and Responses require client and server authentication, as
well as block integrity. To achieve this, Octavia uses a message
authentication code (MAC), specifically $HMAC_{SHA256}$
(equation~\ref{eqn:sign}). By signing the $nonce$, $blockSize$, and
$blockData$ (equation~\ref{eqn:block-signature}), we get the
$blockSignature$. The $blockSignature$ is a globally unique identifier that
could only have been generated by an entity holding the signing $key$, and
thus authenticates both the data and the key holder.

\begin{equation}
sign(data) = HMAC_{SHA256}(key, data)
\label{eqn:sign}
\end{equation}

\begin{equation}
blockSignature = sign(nonce + blockSize + blockData)
\label{eqn:block-signature}
\end{equation}

\subsection{Constants}

This document describes protocol version 0. There are four message types
(although see section~\ref{sec:future-messages}): Retrieval Request = 0,
Retrieval Response = 1, Storage Request = 2, and Storage Response = 3.


\subsection{Retrieval Request (Ret Req)}
\label{sec:RetReq}

Clients send Retrieval Request messages (figure~\ref{fig:RetReq}) to servers
when they want to read a block of data. They specify the protocol version,
$messageType = 0$, and the $blockID$.

\begin{figure}[t]
{\small \begin{verbatim}
typedef struct {
    char version;
    char type;  /* 0 */
    char reserved [2];
    Hash blockID;
} RetReq;
\end{verbatim} }
\caption{The Retrieval Request message format.}
\label{fig:RetReq}
\end{figure}

\subsection{Retrieval Response (Ret Res)}
\label{sec:RetRes}

Servers respond to retrieval requests by sending the block data. They
specify the protocol version, $messageType = 0$, and the $blockData$. Upon
receipt, the client calculates the $blockID$ for the $blockData$. If the
$blockID$ is correct and corresponds to one of the client's pending
retrieval requests, the client accepts the data. Otherwise, the client
ignores the response.

\begin{figure}[t]
{\small \begin{verbatim}
typedef struct {
    char version;
    char type;  /* 1 */
    char reserved [2];
    char blockData [BLOCK\_SIZE];
} RetRes;
\end{verbatim} }
\caption{The Retrieval Response message format.}
\label{fig:RetRes}
\end{figure}

\subsection{Storage Request (Sto Req)}
\label{sec:StoReq}

\begin{figure}[t]
{\small \begin{verbatim}
typedef struct {
    char version;
    char type;  /* 2 */
    char reserved [2];
    Nonce nonce;
    Hash signature;
    char block [BLOCK\_SIZE];
} StoReq;
\end{verbatim} }
\caption{The Storage Request message format.}
\label{fig:StoReq}
\end{figure}

\subsection{Storage Response (Sto Res)}
\label{sec:StoRes}

\begin{figure}[t]
{\small \begin{verbatim}
typedef struct {
    char version;
    char type;  /* 3 */
    char reserved [2];
    Hash signature;
} StoRes;
\end{verbatim} }
\caption{The Storage Response message format.}
\label{fig:StoRes}
\end{figure}

\subsection{Possible Future Message Types}
\label{sec:future-messages}

Revoke Request and Revoke Response, to request that a server delete blocks
with a given $blockID$. Servers MAY set an arbitrary policy for block
deletion or non-deletion in any case; servers SHOULD honor Revoke Requests
when feasible.

TODO: Need a way to map "share names" to directory descriptors. This would
also be the version annoucement mechanism, i.e.\ share names are dynamically
resolved to most recent version of directory descriptor in the common case
(can still use directory descriptors directly, and can still fix share names
to a particular directory version). "My Stuff" -> "blah blah v1".


\section{Security Guarantees}

Data integrity. Client need not care who sends a Retrieval Response, as long
as the integrity check passes. Protection against active network attackers.

Data confidentiality. Server can re-store blocks to improve its apparent
reliability, without violating confidentiality. Confidentiality against
eavesdroppers and unauthorized clients and users (access control).

Client authentication in Storage Request.

Server authentcation in Storage Response.

Replay of Storage Responses prevented with nonce.

Promise of storage, signed by server with trusted key.

Servers can enforce quotas or access control with Storage Requests, since
they know the identity of the client.


\section{Security Concerns}

Strength of hash function.

Servers that lie in Storage Responses. Solution: clients MAY, and probably
SHOULD, store their blocks with multiple servers. Sybil attack?

No defense against traffic analysis, including file and segment size.
Paranoid users may use an anonymizing transport layer such as Tor.


\section{Directory and File Descriptors}


\section{Deployment Scenarios}

\subsection{Global Internet}

\subsection{Friendnet}

\subsection{Low-latency, High-throughput LAN Segment}


\section{Server Policy Expression and Enforcement}

Servers can identify directory/share write clients by their signing keys,
and can therefore define and enforce policies. Servers can also define and
enforce global policies that apply to all clients. Some possible policies
might be:

\begin{itemize}

\item Ring buffer for directory: least-recently-used block deletion.

\item Quotas.

\item Average and/or peak write throughput.

\end{itemize}

Servers cannot, however, enforce policies for read clients without keeping
extra state (remembering which directory(ies)/share(s) a block belongs to.
Policy expression and enforcement is completely orthogonal to the Octavia
network protocol.


\section{Acknowledgements}

Jesse Burns for discussion. Alex Vidergar for discussion and for pointing
out the threat of replayed Storage Responses unless there is a nonce.
Ferguson and Schneier for handy tips. The late, great Octavia Butler for
economy of mechanism and insight.


\end{document}

